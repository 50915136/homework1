# Q1

Ackermann's function A(m,n) is defind as fellow:

A(m,n)=n+1,if m=0; 

A(m,n)=A(m-1,1),if n=0;

A(m,n)=A(m-1,A(m,n-1)),otherwise;

The function is studied because it grow very fast for small values of m and n.

Write a recurvise function for computing this function.

Then write a nonrecursive algorithm for computing Ackermann's function

題目翻譯為


阿克曼函數 A(m, n) 定義如下：

當 m = 0 時，A(m, n) = n + 1;

當 n = 0 時，A(m, n) = A(m - 1, 1);

否則，A(m, n) = A(m - 1, A(m, n - 1))。

這個函數因為在 m 和 n 的小數值下增長非常快而受到研究。

請編寫一個遞迴函數來計算這個函數。

然後編寫一個非遞迴算法來計算阿克曼函數。

遞迴結果圖片如下:

![image](https://github.com/50915136/homework1/blob/main/%E9%81%9E%E8%BF%B4%E9%98%BF%E5%85%8B%E6%9B%BC1.PNG)


![image](https://github.com/50915136/homework1/blob/main/%E9%81%9E%E8%BF%B4%E9%98%BF%E5%85%8B%E6%9B%BC2.PNG)


非遞迴結果圖片如下:

![image](https://github.com/50915136/homework1/blob/main/%E9%9D%9E%E9%81%9E%E8%BF%B4%E9%98%BF%E5%85%8B%E6%9B%BC1.PNG)


![image](https://github.com/50915136/homework1/blob/main/%E9%9D%9E%E9%81%9E%E8%BF%B4%E9%98%BF%E5%85%8B%E6%9B%BC2.PNG)

非遞迴採用堆疊(stack)方式，

保存了每一層遞迴的計算狀態。

當計算 A(m, n - 1) 完成後，堆疊會提供先前保存的狀態 (m - 1, 0)

使得程式可以繼續進行後續的計算。這種方法有效地模擬了遞迴的回溯過程，而無需真正地使用遞迴，從而避免了潛在的堆疊溢出問題。


程式碼皆由用chatGTP撰寫，由Dev C++編譯執行。


# Q2

If S is a set of n elements ,powerset of S is the set of all possible subsets of S.

For example, if S=(a,b,c) then powerset (S)={(),(a),(b),(c),(a,b),(a,c),(b,c),(a,b,c}.

Write a recursive function to compute.


題目翻譯為:

如果 S 是一個包含 n 個元素的集合，那麼 S 的冪集就是 S 的所有可能子集的集合。

例如，如果 S = {a, b, c}，那麼 S 的冪集就是 {(), (a), (b), (c), (a, b), (a, c), (b, c), (a, b, c)}。

請寫一個遞迴函數來計算這個冪集。

結果如下:

![image](https://github.com/50915136/homework1/blob/main/powerset.PNG)

先輸入陣列大小，接著輸入陣列內容，之後從空集合開始輸出，直到所有集合接輸出完畢。

程式碼皆由用chatGTP撰寫，由Dev C++編譯執行。
